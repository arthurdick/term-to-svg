<?php

/**
 * A command-line tool to convert terminal session recordings into animated SVG.
 *
 * This script works by parsing typescript and timing files generated by the `script` command.
 * It interprets ANSI escape codes for cursor movement, color changes, inverse video,
 * character deletion/insertion, line deletion/insertion, scroll regions, and screen
 * clearing, then generates SVG elements with animations to replay the session.
 *
 * The generated SVG will freeze on the last frame for 5 seconds, then loop.
 *
 * @author Arthur Dick
 * @version 2.0.1
 */

namespace ArthurDick\TermToSvg;

class TerminalToSvgConverter
{
    public const CONFIG = [
    'rows' => 24,
    'cols' => 80,
    'font_size' => 14,
    'line_height_factor' => 1.2,
    'font_family' => 'Menlo, Monaco, "Courier New", monospace',
    'default_fg' => '#e0e0e0', // Default text color
    'default_bg' => '#1a1a1a', // Terminal background color
];
    // --- Parser States ---
    private const STATE_GROUND = 0;
    private const STATE_ESCAPE = 1;
    private const STATE_CSI_PARAM = 2;
    private const STATE_OSC_STRING = 3;
    private const STATE_CHARSET = 4; // Designate G0/G1 charset

    // Lists of common terminal commands that don't affect the visual output
    // and can be safely ignored without generating warnings.
    private const WONT_IMPLEMENT_CSI = [
        'n', // Device Status Report
        's', // Save Cursor Position (ANSI.SYS)
        'u', // Restore Cursor Position (ANSI.SYS)
        't', // Window Manipulation
    ];
    private const WONT_IMPLEMENT_DEC = [
        '1h', '1l',   // Set/Reset Cursor Key Mode
        '7h', '7l',   // Set/Reset Autowrap Mode
        '12h', '12l',  // Start/Stop Blinking Cursor
        '1000h', '1000l', '1002h', '1002l', '1003h', '1003l', // Mouse Reporting
        '1004h', '1004l', '1005h', '1005l', '1006h', '1006l', // Mouse Reporting
        '2004h', '2004l', // Set/Reset Bracketed Paste Mode
    ];
    private const WONT_IMPLEMENT_ESC = [
        '7', '8', // DECSC / DECRC (Save/Restore Cursor)
    ];

    private $typescriptHandle;
    private $timingData;
    private $config;

    // Virtual Terminal State
    private int $cursorX = 0;
    private int $cursorY = 0;
    private int $savedCursorX = 0;
    private int $savedCursorY = 0;
    private float $currentTime = 0.0;
    private array $currentStyle = []; // Initialized in constructor
    private bool $cursorVisible = true;
    private array $cursorEvents = [];

    // Screen buffer management
    private array $mainBuffer = [];
    private array $altBuffer = [];
    private bool $altScreenActive = false;
    private int $mainScrollOffset = 0;
    private int $altScrollOffset = 0;
    private array $mainScrollEvents = [];
    private array $altScrollEvents = [];
    private array $screenSwitchEvents = [];

    // Scrolling Region
    private int $scrollTop = 0;
    private int $scrollBottom; // Initialized in constructor

    private array $cssRules = [];
    private int $classCounter = 0;

    // Total animation duration
    private float $totalDuration = 0.0;

    // ANSI SGR code to CSS color mapping
    private const ANSI_16_COLORS = [
        // Standard
        30 => '#2e3436', 31 => '#cc0000', 32 => '#4e9a06', 33 => '#c4a000',
        34 => '#3465a4', 35 => '#75507b', 36 => '#06989a', 37 => '#d3d7cf',
        // Bright
        90 => '#555753', 91 => '#ef2929', 92 => '#8ae234', 93 => '#fce94f',
        94 => '#729fcf', 95 => '#ad7fa8', 96 => '#34e2e2', 97 => '#eeeeec',
    ];

    public function __construct(string $typescriptPath, string $timingPath, array $config)
    {
        $this->config = $config;
        $this->resetStyle();

        $this->typescriptHandle = @fopen($typescriptPath, 'r');
        if (!$this->typescriptHandle) {
            // In a testing context, the file might not exist, which is fine.
            // Don't throw an exception here.
            return;
        }

        $firstLine = fgets($this->typescriptHandle);
        if ($firstLine && preg_match('/COLUMNS="(\d+)".*?LINES="(\d+)"/', $firstLine, $matches)) {
            $this->config['cols'] = (int)$matches[1];
            $this->config['rows'] = (int)$matches[2];
            // Suppress output during tests
            if (php_sapi_name() === 'cli' && realpath($_SERVER['SCRIPT_FILENAME']) === realpath(__FILE__)) {
                echo "✅ Detected geometry from log file: {$this->config['cols']}x{$this->config['rows']}\n";
            }
        } else {
            if (php_sapi_name() === 'cli' && realpath($_SERVER['SCRIPT_FILENAME']) === realpath(__FILE__)) {
                echo "⚠️  Warning: Could not detect geometry from log file. Using default dimensions.\n";
            }
        }

        $this->scrollBottom = $this->config['rows'] - 1;

        $this->timingData = $this->parseTimingFile($timingPath);
    }

    private function resetStyle(): void
    {
        $this->currentStyle = [
            'fg' => 'fg-default',
            'bg' => 'bg-default',
            'bold' => false,
            'inverse' => false,
            'fg_hex' => null,
            'bg_hex' => null,
        ];
    }

    private function logWarning(string $message): void
    {
        // Suppress warnings during tests
        if (php_sapi_name() !== 'cli' || realpath($_SERVER['SCRIPT_FILENAME']) !== realpath(__FILE__)) {
            return;
        }
        fwrite(STDERR, "⚠️  Warning: {$message}\n");
    }

    public function __destruct()
    {
        if ($this->typescriptHandle) {
            fclose($this->typescriptHandle);
        }
    }

    private function parseTimingFile(string $path): array
    {
        if (!file_exists($path) || !is_readable($path)) {
            return []; // Return empty array if file is not accessible
        }
        $lines = file($path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        $data = [];
        foreach ($lines as $line) {
            $parts = explode(' ', $line, 2);
            if (count($parts) === 2) {
                list($delay, $bytes) = $parts;
                $data[] = ['delay' => (float)$delay, 'bytes' => (int)$bytes];
            }
        }
        return $data;
    }

    public function convert(): string
    {
        // Add the initial cursor state at time 0
        $this->cursorEvents[] = ['time' => 0.0, 'x' => $this->cursorX, 'y' => $this->cursorY, 'visible' => $this->cursorVisible];

        while (($timingLine = array_shift($this->timingData)) !== null) {
            $this->currentTime += $timingLine['delay'];
            if ($timingLine['bytes'] > 0 && $this->typescriptHandle) {
                $chunk = fread($this->typescriptHandle, $timingLine['bytes']);
                $this->processChunk($chunk);
            }
        }

        $this->totalDuration = $this->currentTime;

        return $this->generateSvg();
    }

    /**
     * Process a chunk of terminal data using a state machine parser.
     * This method iterates through each character, tracking the parser's state
     * to correctly handle printable characters and ANSI escape sequences.
     */
    private function processChunk(string $chunk): void
    {
        static $state = self::STATE_GROUND;
        static $params = '';
        static $isDecPrivate = false;

        $characters = mb_str_split($chunk, 1, 'UTF-8');
        $charCount = count($characters);

        for ($i = 0; $i < $charCount; $i++) {
            $char = $characters[$i];

            switch ($state) {
                case self::STATE_GROUND:
                    if ($char === "\x1b") {
                        $state = self::STATE_ESCAPE;
                    } else {
                        $this->handleCharacter($char);
                    }
                    break;

                case self::STATE_ESCAPE:
                    if ($char === '[') {
                        $params = '';
                        $isDecPrivate = false;
                        $state = self::STATE_CSI_PARAM;
                    } elseif ($char === ']') {
                        $state = self::STATE_OSC_STRING;
                    } elseif ($char === '(') {
                        $state = self::STATE_CHARSET;
                    } elseif ($char === 'D') { // IND - Index
                        $this->cursorY++;
                        if ($this->cursorY > $this->scrollBottom) {
                            $scrollCount = $this->cursorY - $this->scrollBottom;
                            $this->doStreamScroll($scrollCount);
                            $this->cursorY = $this->scrollBottom;
                        }
                        $this->recordCursorState();
                        $state = self::STATE_GROUND;
                    } elseif ($char === 'M') { // RI - Reverse Index
                        $this->cursorY--;
                        if ($this->cursorY < $this->scrollTop) {
                            $this->doScrollDown(1); // Scroll region down by 1
                            $this->cursorY = $this->scrollTop;
                        }
                        $this->recordCursorState();
                        $state = self::STATE_GROUND;
                    } elseif ($char === 'E') { // NEL - Next Line
                        $this->cursorX = 0;
                        $this->cursorY++;
                        if ($this->cursorY > $this->scrollBottom) {
                            $scrollCount = $this->cursorY - $this->scrollBottom;
                            $this->doStreamScroll($scrollCount);
                            $this->cursorY = $this->scrollBottom;
                        }
                        $this->recordCursorState();
                        $state = self::STATE_GROUND;
                    } else {
                        // Unhandled escape sequence, return to ground state
                        if (!in_array($char, self::WONT_IMPLEMENT_ESC)) {
                            $this->logWarning("Unsupported escape sequence: ESC {$char}");
                        }
                        $state = self::STATE_GROUND;
                    }
                    break;

                case self::STATE_CHARSET:
                    // We don't implement different charsets, just consume the command
                    // and return to ground state. The command is usually one character.
                    $state = self::STATE_GROUND;
                    break;

                case self::STATE_OSC_STRING:
                    // Operating System Commands are ignored. We just consume characters
                    // until we see a BEL (0x07) or a String Terminator (ESC + \).
                    if ($char === "\x07") {
                        $state = self::STATE_GROUND;
                    } elseif ($char === "\x1b" && ($i + 1 < $charCount) && $characters[$i + 1] === '\\') {
                        $i++; // Consume the backslash as well
                        $state = self::STATE_GROUND;
                    }
                    break;

                case self::STATE_CSI_PARAM:
                    // Check for DEC Private Mode marker at the start of params
                    if ($params === '' && $char === '?') {
                        $isDecPrivate = true;
                        continue 2; // continue the loop, not the switch
                    }

                    // Accumulate parameter string (digits and semicolons)
                    if (ctype_digit($char) || $char === ';') {
                        $params .= $char;
                    } else {
                        // Final character of the sequence (A-Z, a-z, etc.)
                        if ($isDecPrivate) {
                            $this->handleDecPrivateMode($params . $char);
                        } else {
                            $paramArray = ($params === '') ? [] : explode(';', $params);
                            $this->handleAnsiCommand($char, $paramArray);
                        }
                        $state = self::STATE_GROUND;
                    }
                    break;
            }
        }
    }


    private function handleDecPrivateMode(string $command): void
    {
        if ($command === '1049h') {
            // Save the main buffer's cursor position
            $this->savedCursorX = $this->cursorX;
            $this->savedCursorY = $this->cursorY;

            $this->altScreenActive = true;
            $this->screenSwitchEvents[] = ['time' => $this->currentTime, 'type' => 'to_alt'];

            // The application (e.g., vim, less) is responsible for clearing the
            // screen upon entering the alternate buffer. Resetting the cursor
            // and scroll region is the correct behavior.

            $this->cursorX = 0;
            $this->cursorY = 0;
            $this->recordCursorState(); // Record move
            $this->setScrollRegion([]);

        } elseif ($command === '1049l') {
            // Switch to main buffer and restore cursor position
            $this->altScreenActive = false;
            $this->screenSwitchEvents[] = ['time' => $this->currentTime, 'type' => 'to_main'];

            // Reset scroll region BEFORE restoring the cursor.
            $this->setScrollRegion([]);

            // Now, restore the saved cursor position.
            $this->cursorX = $this->savedCursorX;
            $this->cursorY = $this->savedCursorY;
            $this->recordCursorState(); // Record move
        } elseif ($command === '25l') {
            $this->setCursorVisibility(false);
        } elseif ($command === '25h') {
            $this->setCursorVisibility(true);
        } else {
            if (!in_array($command, self::WONT_IMPLEMENT_DEC)) {
                $this->logWarning("Unsupported DEC Private Mode command: ?{$command}");
            }
        }
    }

    private function handleCharacter(string $char): void
    {
        switch ($char) {
            case "\r":
                $this->cursorX = 0;
                break;
            case "\n":
                $this->cursorY++;
                // The scroll check below will handle recording state if a scroll occurs
                break;
            case "\x08":
            case "\x7f":
                $this->cursorX = max(0, $this->cursorX - 1);
                $this->recordCursorState();
                break;
            case "\t":
                $this->cursorX = min($this->config['cols'] - 1, (int)($this->cursorX / 8 + 1) * 8);
                $this->recordCursorState();
                break;
            default:
                if (mb_check_encoding($char, 'UTF-8') && preg_match('/[[:print:]]/u', $char)) {
                    if ($this->cursorX >= $this->config['cols']) {
                        $this->cursorX = 0;
                        $this->cursorY++;
                    }
                    $this->writeCharToHistory($char);
                    $this->cursorX++;
                }
                break;
        }

        // Use the correct scroll method for stream scrolling
        if ($this->cursorY > $this->scrollBottom) {
            $scrollCount = $this->cursorY - $this->scrollBottom;
            $this->doStreamScroll($scrollCount);
            $this->cursorY = $this->scrollBottom;
            $this->recordCursorState(); // Record cursor move after scroll
        } else {
            $this->recordCursorState(); // Record if no scroll occurred but Y changed (e.g., newline)
        }
    }

    private function writeCharToHistory(string $char): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;
        $absoluteY = $this->cursorY + $scrollOffset;

        if (isset($buffer[$absoluteY][$this->cursorX])) {
            $lastIndex = count($buffer[$absoluteY][$this->cursorX]) - 1;
            if (!isset($buffer[$absoluteY][$this->cursorX][$lastIndex]['endTime'])) {
                $buffer[$absoluteY][$this->cursorX][$lastIndex]['endTime'] = $this->currentTime;
            }
        }
        $buffer[$absoluteY][$this->cursorX][] = [
            'char'      => htmlspecialchars($char, ENT_XML1),
            'style'     => $this->currentStyle,
            'startTime' => $this->currentTime,
        ];
    }

    private function writeBlankCharToHistory(int $x, int $y): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;
        $absoluteY = $y + $scrollOffset;

        $this->endLifespanForLine($absoluteY, $x, 1);

        $buffer[$absoluteY][$x][] = [
            'char'      => '&#160;',
            'style'     => $this->currentStyle,
            'startTime' => $this->currentTime,
        ];
    }

    private function handleAnsiCommand(string $command, array $params): void
    {
        $p = array_map('intval', $params);
        $moved = false;
        switch ($command) {
            case 'm': $this->setGraphicsMode($params);
                break;
            case 'H': case 'f':
                $this->cursorY = max(0, ($p[0] ?? 1) - 1);
                $this->cursorX = max(0, ($p[1] ?? 1) - 1);
                $moved = true;
                break;
            case 'A': $this->cursorY = max(0, $this->cursorY - ($p[0] ?? 1));
                $moved = true;
                break;
            case 'B': $this->cursorY = min($this->config['rows'] - 1, $this->cursorY + ($p[0] ?? 1));
                $moved = true;
                break;
            case 'C': $this->cursorX = min($this->config['cols'] - 1, $this->cursorX + ($p[0] ?? 1));
                $moved = true;
                break;
            case 'D': $this->cursorX = max(0, $this->cursorX - ($p[0] ?? 1));
                $moved = true;
                break;
            case 'G': // CHA - Cursor Character Absolute
                $this->cursorX = max(0, ($p[0] ?? 1) - 1);
                $moved = true;
                break;
            case 'd': $this->cursorY = max(0, ($p[0] ?? 1) - 1);
                $moved = true;
                break;
            case 'J': $this->eraseInDisplay($p[0] ?? 0);
                break;
            case 'K': $this->eraseInLine($p[0] ?? 0);
                break;
            case '@': $this->insertCharacters($p[0] ?? 1);
                break;
            case 'P': $this->deleteCharacters($p[0] ?? 1);
                break;
            case 'r': $this->setScrollRegion($p);
                break;
            case 'L': $this->insertLines($p[0] ?? 1);
                break;
            case 'M': $this->deleteLines($p[0] ?? 1);
                break;
            case 'S': $this->doScrollUp($p[0] ?? 1);
                break;
            case 'T': $this->doScrollDown($p[0] ?? 1);
                break;
            default:
                if (!in_array($command, self::WONT_IMPLEMENT_CSI)) {
                    $this->logWarning("Unsupported CSI command: '" . implode(';', $params) . "{$command}'");
                }
                break;
        }

        if ($moved) {
            $this->recordCursorState();
        }
    }

    private function setGraphicsMode(array $params): void
    {
        if (empty($params)) {
            $params = [0];
        }

        $i = 0;
        while ($i < count($params)) {
            $p = intval($params[$i]);
            $handled = false;

            if ($p === 0) {
                $this->resetStyle();
                $handled = true;
            } elseif ($p === 1) {
                $this->currentStyle['bold'] = true;
                $handled = true;
            } elseif ($p === 7) {
                $this->currentStyle['inverse'] = true;
                $handled = true;
            } elseif ($p === 22) {
                $this->currentStyle['bold'] = false;
                $handled = true;
            } elseif ($p === 27) {
                $this->currentStyle['inverse'] = false;
                $handled = true;
            } elseif (array_key_exists($p, self::ANSI_16_COLORS)) {
                $this->currentStyle['fg'] = 'fg-' . $p;
                $this->currentStyle['fg_hex'] = null;
                $handled = true;
            } elseif (array_key_exists($p - 10, self::ANSI_16_COLORS)) {
                $this->currentStyle['bg'] = 'bg-' . $p;
                $this->currentStyle['bg_hex'] = null;
                $handled = true;
            } elseif ($p === 39) {
                $this->currentStyle['fg'] = 'fg-default';
                $this->currentStyle['fg_hex'] = null;
                $handled = true;
            } elseif ($p === 49) {
                $this->currentStyle['bg'] = 'bg-default';
                $this->currentStyle['bg_hex'] = null;
                $handled = true;
            } elseif ($p === 38 || $p === 48) { // Extended colors
                $colorType = ($p === 38) ? 'fg' : 'bg';
                if (isset($params[$i + 1]) && intval($params[$i + 1]) === 5 && isset($params[$i + 2])) {
                    $colorCode = intval($params[$i + 2]);
                    $this->currentStyle[$colorType . '_hex'] = $this->mapAnsi256ToHex($colorCode);
                    $this->currentStyle[$colorType] = 'fg-default';
                    $i += 2;
                    $handled = true;
                } elseif (isset($params[$i + 1]) && intval($params[$i + 1]) === 2) {
                    if (isset($params[$i + 2]) && isset($params[$i + 3]) && isset($params[$i + 4])) {
                        $this->currentStyle[$colorType . '_hex'] = sprintf("#%02x%02x%02x", intval($params[$i + 2]), intval($params[$i + 3]), intval($params[$i + 4]));
                        $i += 4;
                        $handled = true;
                    }
                }
            }

            if (!$handled) {
                $this->logWarning("Unsupported SGR parameter: {$p}");
            }
            $i++;
        }
    }

    private function mapAnsi256ToHex(int $code): string
    {
        if ($code < 8) {
            return self::ANSI_16_COLORS[$code + 30];
        }
        if ($code < 16) {
            return self::ANSI_16_COLORS[$code - 8 + 90];
        }
        if ($code >= 16 && $code <= 231) {
            $code -= 16;
            $r = floor($code / 36);
            $g = floor(($code % 36) / 6);
            $b = $code % 6;
            $levels = [0, 95, 135, 175, 215, 255];
            return sprintf("#%02x%02x%02x", $levels[$r], $levels[$g], $levels[$b]);
        }
        if ($code >= 232 && $code <= 255) {
            $level = ($code - 232) * 10 + 8;
            return sprintf("#%02x%02x%02x", $level, $level, $level);
        }
        return $this->config['default_fg'];
    }

    private function eraseInDisplay(int $mode): void
    {
        if ($mode === 0) { // Erase from cursor to end of screen
            $this->eraseInLine(0);
            for ($y = $this->cursorY + 1; $y < $this->config['rows']; $y++) {
                $this->clearLine($y);
            }
        } elseif ($mode === 1) { // Erase from start of screen to cursor
            for ($y = 0; $y < $this->cursorY; $y++) {
                $this->clearLine($y);
            }
            $this->eraseInLine(1);
        } elseif ($mode === 2 || $mode === 3) { // Erase entire screen
            for ($y = 0; $y < $this->config['rows']; $y++) {
                $this->clearLine($y);
            }
        }
    }

    private function clearLine(int $y): void
    {
        for ($x = 0; $x < $this->config['cols']; $x++) {
            $this->writeBlankCharToHistory($x, $y);
        }
    }

    private function eraseInLine(int $mode): void
    {
        $startX = 0;
        $endX = $this->config['cols'];

        if ($mode === 0) { // From cursor to end of line
            $startX = $this->cursorX;
        } elseif ($mode === 1) { // From start of line to cursor
            $endX = $this->cursorX + 1;
        } // Mode 2 is full line

        for ($x = $startX; $x < $endX; $x++) {
            $this->writeBlankCharToHistory($x, $this->cursorY);
        }
    }

    private function deleteCharacters(int $n = 1): void
    {
        $n = max(1, $n);
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;
        $y = $this->cursorY + $scrollOffset;
        $x_start = $this->cursorX;
        $cols = $this->config['cols'];

        if (!isset($buffer[$y])) {
            return;
        }

        for ($x = $x_start; $x < $cols; $x++) {
            $x_source = $x + $n;
            $this->endLifespanForLine($y, $x, 1);
            if ($x_source < $cols && isset($buffer[$y][$x_source]) && !empty($buffer[$y][$x_source])) {
                $lastIndex = count($buffer[$y][$x_source]) - 1;
                $cellToMove = $buffer[$y][$x_source][$lastIndex];
                if (!isset($cellToMove['endTime']) || $cellToMove['endTime'] > $this->currentTime) {
                    $buffer[$y][$x][] = [
                       'char'      => $cellToMove['char'],
                       'style'     => $cellToMove['style'],
                       'startTime' => $this->currentTime,
                    ];
                }
            }
        }
    }

    private function insertCharacters(int $n = 1): void
    {
        $n = max(1, $n);
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;
        $y = $this->cursorY + $scrollOffset;
        $x_start = $this->cursorX;
        $cols = $this->config['cols'];

        if (!isset($buffer[$y])) {
            return;
        }

        // Shift existing characters to the right, starting from the end of the line
        for ($x = $cols - 1; $x >= $x_start + $n; $x--) {
            $x_source = $x - $n;
            if (isset($buffer[$y][$x_source]) && !empty($buffer[$y][$x_source])) {
                // End the life of any character at the destination
                $this->endLifespanForLine($y, $x, 1);

                // Find the last "live" state of the source character to move it
                $lastIndex = count($buffer[$y][$x_source]) - 1;
                $cellToMove = $buffer[$y][$x_source][$lastIndex];

                if (!isset($cellToMove['endTime']) || $cellToMove['endTime'] > $this->currentTime) {
                    $buffer[$y][$x][] = [
                        'char'      => $cellToMove['char'],
                        'style'     => $cellToMove['style'],
                        'startTime' => $this->currentTime,
                    ];
                }
            } else {
                // If the source is empty, clear the destination
                unset($buffer[$y][$x]);
            }
        }

        // Insert new blank characters at the cursor position
        for ($i = 0; $i < $n; $i++) {
            $this->writeBlankCharToHistory($x_start + $i, $this->cursorY);
        }
    }

    private function setScrollRegion(array $params): void
    {
        $top = (isset($params[0]) && $params[0] > 0) ? $params[0] - 1 : 0;
        $bottom = (isset($params[1]) && $params[1] > 0) ? $params[1] - 1 : $this->config['rows'] - 1;

        if ($top < $bottom) {
            $this->scrollTop = $top;
            $this->scrollBottom = $bottom;
        } else { // Reset on invalid region
            $this->scrollTop = 0;
            $this->scrollBottom = $this->config['rows'] - 1;
        }
        // As per spec, move cursor to home on region change
        $this->cursorX = 0;
        $this->cursorY = 0;
        $this->recordCursorState();
    }

    private function insertLines(int $n): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;

        // Only works if cursor is within the scroll region
        if ($this->cursorY < $this->scrollTop || $this->cursorY > $this->scrollBottom) {
            return;
        }

        // End lifespan for lines being pushed out of the region
        for ($i = 0; $i < $n; $i++) {
            $y_to_kill = $this->scrollBottom - $i;
            if ($y_to_kill >= $this->cursorY) {
                $this->endLifespanForLine($y_to_kill + $scrollOffset, 0);
            }
        }

        // Shift lines down
        for ($y = $this->scrollBottom; $y >= $this->cursorY + $n; $y--) {
            $src_y = $y - $n + $scrollOffset;
            $dest_y = $y + $scrollOffset;
            $buffer[$dest_y] = $buffer[$src_y] ?? [];
        }

        // Insert new blank lines
        for ($y = $this->cursorY; $y < $this->cursorY + $n; $y++) {
            $absY = $y + $scrollOffset;
            $buffer[$absY] = []; // Clear the line in the buffer
            for ($x = 0; $x < $this->config['cols']; $x++) {
                $this->writeBlankCharToHistory($x, $y);
            }
        }
    }

    private function deleteLines(int $n): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;

        // Only works if cursor is within the scroll region
        if ($this->cursorY < $this->scrollTop || $this->cursorY > $this->scrollBottom) {
            return;
        }

        // End lifespan for lines being deleted
        for ($i = 0; $i < $n; $i++) {
            $this->endLifespanForLine($this->cursorY + $i + $scrollOffset, 0);
        }

        // Shift lines up
        for ($y = $this->cursorY; $y <= $this->scrollBottom - $n; $y++) {
            $src_y = $y + $n + $scrollOffset;
            $dest_y = $y + $scrollOffset;
            $buffer[$dest_y] = $buffer[$src_y] ?? [];
        }

        // Add new blank lines at the bottom of the region
        for ($y = $this->scrollBottom - $n + 1; $y <= $this->scrollBottom; $y++) {
            $absY = $y + $scrollOffset;
            $buffer[$absY] = [];
            for ($x = 0; $x < $this->config['cols']; $x++) {
                $this->writeBlankCharToHistory($x, $y);
            }
        }
    }

    private function doScrollUp(int $n): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;

        for ($i = 0; $i < $n; $i++) {
            // End lifespan for the top line of the region
            $this->endLifespanForLine($this->scrollTop + $scrollOffset, 0);

            // Shift lines up
            for ($y = $this->scrollTop; $y < $this->scrollBottom; $y++) {
                $src_y = $y + 1 + $scrollOffset;
                $dest_y = $y + $scrollOffset;
                $buffer[$dest_y] = $buffer[$src_y] ?? [];
            }

            // Add a blank line at the bottom
            $bottom_y = $this->scrollBottom;
            $buffer[$bottom_y + $scrollOffset] = [];
            for ($x = 0; $x < $this->config['cols']; $x++) {
                $this->writeBlankCharToHistory($x, $bottom_y);
            }
        }
    }

    private function doScrollDown(int $n): void
    {
        $buffer = &$this->getActiveBuffer();
        $scrollOffset = $this->altScreenActive ? $this->altScrollOffset : $this->mainScrollOffset;

        for ($i = 0; $i < $n; $i++) {
            // End lifespan for the bottom line of the region
            $this->endLifespanForLine($this->scrollBottom + $scrollOffset, 0);

            // Shift lines down
            for ($y = $this->scrollBottom; $y > $this->scrollTop; $y--) {
                $src_y = $y - 1 + $scrollOffset;
                $dest_y = $y + $scrollOffset;
                $buffer[$dest_y] = $buffer[$src_y] ?? [];
            }

            // Add a blank line at the top
            $top_y = $this->scrollTop;
            $buffer[$top_y + $scrollOffset] = [];
            for ($x = 0; $x < $this->config['cols']; $x++) {
                $this->writeBlankCharToHistory($x, $top_y);
            }
        }
    }

    private function doStreamScroll(int $n = 1): void
    {
        $scrollOffsetRef = &$this->getActiveScrollOffsetRef();
        $scrollEventsRef = &$this->getActiveScrollEventsRef();

        for ($i = 0; $i < $n; $i++) {
            // Mark the top-most line as ending its lifespan
            $this->endLifespanForLine($scrollOffsetRef, 0);
            // Record the animation event for the SVG transform
            $scrollEventsRef[] = ['time' => $this->currentTime, 'offset' => $scrollOffsetRef];
            // Increment the global offset, so new lines are written "below" the old ones
            $scrollOffsetRef++;
        }
    }

    private function endLifespanForLine(int $y, int $startX, ?int $count = null): void
    {
        $buffer = &$this->getActiveBuffer();
        if (!isset($buffer[$y])) {
            return;
        }
        $endX = $count !== null ? $startX + $count : $this->config['cols'];
        for ($x = $startX; $x < $endX; $x++) {
            if (isset($buffer[$y][$x]) && !empty($buffer[$y][$x])) {
                $lastIndex = count($buffer[$y][$x]) - 1;
                if (!isset($buffer[$y][$x][$lastIndex]['endTime'])) {
                    $buffer[$y][$x][$lastIndex]['endTime'] = $this->currentTime;
                }
            }
        }
    }

    private function &getActiveBuffer(): array
    {
        if ($this->altScreenActive) {
            return $this->altBuffer;
        } else {
            return $this->mainBuffer;
        }
    }

    private function &getActiveScrollOffsetRef(): int
    {
        if ($this->altScreenActive) {
            return $this->altScrollOffset;
        }
        return $this->mainScrollOffset;
    }

    private function &getActiveScrollEventsRef(): array
    {
        if ($this->altScreenActive) {
            return $this->altScrollEvents;
        }
        return $this->mainScrollEvents;
    }

    private function generateSvg(): string
    {
        $charHeight = $this->config['font_size'] * $this->config['line_height_factor'];
        $charWidth = $this->config['font_size'] * 0.6;
        $svgWidth = $charWidth * $this->config['cols'];
        $svgHeight = ($charHeight * $this->config['rows']) + ($this->config['font_size'] * 0.2); // Add padding for descenders

        list($mainText, $mainRects, $mainScroll) = $this->renderBuffer($this->mainBuffer, $this->mainScrollEvents, $charHeight, $charWidth);
        list($altText, $altRects, $altScroll) = $this->renderBuffer($this->altBuffer, $this->altScrollEvents, $charHeight, $charWidth);

        $cursorAnims = $this->generateCursorAnimations($charWidth, $charHeight);

        $mainAnims = '';
        $altAnims = '';

        foreach ($this->screenSwitchEvents as $event) {
            if ($event['type'] === 'to_alt') {
                $mainAnims .= sprintf('        <set attributeName="display" to="none" begin="loop.begin+%.4fs" />' . "\n", $event['time']);
                $altAnims .= sprintf('        <set attributeName="display" to="inline" begin="loop.begin+%.4fs" />' . "\n", $event['time']);
            } else { // to_main
                $mainAnims .= sprintf('        <set attributeName="display" to="inline" begin="loop.begin+%.4fs" />' . "\n", $event['time']);
                $altAnims .= sprintf('        <set attributeName="display" to="none" begin="loop.begin+%.4fs" />' . "\n", $event['time']);
            }
        }

        $mainAnims .= '        <set attributeName="display" to="inline" begin="loop.begin" />' . "\n";
        $altAnims .= '        <set attributeName="display" to="none" begin="loop.begin" />' . "\n";

        return $this->getSvgTemplate($svgWidth, $svgHeight, $mainText, $mainRects, $mainScroll, $altText, $altRects, $altScroll, $mainAnims, $altAnims, $cursorAnims, $this->totalDuration);
    }

    private function getHexForColor(string $type, array $style): string
    {
        if (!empty($style[$type . '_hex'])) {
            return $style[$type . '_hex'];
        }
        $class = $style[$type];
        if ($class === 'fg-default') {
            return $this->config['default_fg'];
        }
        if ($class === 'bg-default') {
            return $this->config['default_bg'];
        }
        $parts = explode('-', $class);
        $code = (int)end($parts);
        // This logic is a bit brittle, but handles the ANSI mapping for this script
        if ($code >= 90 && $code <= 97) { /* bright fg */
        } elseif ($code >= 100 && $code <= 107) {
            $code -= 10;
        } // bright bg
        elseif ($code >= 40 && $code <= 47) {
            $code -= 10;
        } // standard bg
        return self::ANSI_16_COLORS[$code] ?? ($type === 'fg' ? $this->config['default_fg'] : $this->config['default_bg']);
    }

    private function renderBuffer(array $buffer, array $scrollEvents, float $charHeight, float $charWidth): array
    {
        $rectElements = '';
        $textElements = '';
        $scrollAnimations = '';

        foreach ($buffer as $y => $row) {
            $x = 0;
            while ($x < $this->config['cols']) {
                if (!isset($row[$x]) || empty($row[$x])) {
                    $x++;
                    continue;
                }

                foreach ($row[$x] as $cell) {
                    if (!isset($cell['startTime'])) {
                        continue;
                    }

                    $current_x = $x;
                    $textChunk = '';
                    $style = $cell['style'];

                    while ($current_x < $this->config['cols'] &&
                           isset($row[$current_x]) &&
                           ($foundCell = $this->findCellMatching($row[$current_x], $cell)) !== null) {
                        $textChunk .= $foundCell['char'];
                        $this->markCellProcessed($row[$current_x], $foundCell);
                        $current_x++;
                    }

                    if ($textChunk === '') {
                        continue;
                    }

                    $fgHex = $this->getHexForColor('fg', $style);
                    $bgHex = $this->getHexForColor('bg', $style);

                    if (!empty($style['inverse'])) {
                        list($fgHex, $bgHex) = [$bgHex, $fgHex];
                    }

                    $visibilityAnims = sprintf(
                        '<set attributeName="visibility" to="visible" begin="loop.begin+%.4fs" />',
                        $cell['startTime']
                    );
                    if (isset($cell['endTime'])) {
                        $visibilityAnims .= sprintf(
                            '<set attributeName="visibility" to="hidden" begin="loop.begin+%.4fs" />',
                            $cell['endTime']
                        );
                    }
                    $visibilityAnims .= '<set attributeName="visibility" to="hidden" begin="loop.begin" />';

                    $chunkWidth = ($current_x - $x) * $charWidth;

                    if ($bgHex !== $this->config['default_bg']) {
                        $rectX = $x * $charWidth;
                        $rectY = $y * $charHeight;
                        $bgRule = sprintf('fill:%s;', $bgHex);
                        $bgClass = $this->getClassName($bgRule);

                        $rectElements .= sprintf(
                            '        <rect class="%s" x="%.2F" y="%.2F" width="%.2F" height="%.2F">%s</rect>' . "\n",
                            $bgClass,
                            $rectX,
                            $rectY,
                            $chunkWidth,
                            $charHeight,
                            $visibilityAnims
                        );
                    }

                    // First, create a version of the chunk for trimming that also handles non-breaking spaces.
                    $trimmedChunk = trim(str_replace('&#160;', ' ', $textChunk));

                    // Only create the <text> element if there's non-whitespace content.
                    if ($trimmedChunk !== '') {
                        $textX = $x * $charWidth;
                        $textY = ($y + 1) * $charHeight - ($charHeight - $this->config['font_size']) / 2;

                        $textCss = sprintf('fill:%s;', $fgHex);
                        if ($style['bold']) {
                            $textCss .= 'font-weight:bold;';
                        }
                        $textClass = $this->getClassName($textCss);

                        // Conditionally add xml:space="preserve" only when needed
                        $spacePreserveAttr = '';
                        if (str_starts_with($textChunk, ' ') || str_ends_with($textChunk, ' ')) {
                            $spacePreserveAttr = ' xml:space="preserve"';
                        }

                        $textElements .= sprintf(
                            '        <text class="%s" x="%.2F" y="%.2F"%s>%s%s</text>' . "\n",
                            $textClass,
                            $textX,
                            $textY,
                            $spacePreserveAttr,
                            $textChunk,
                            $visibilityAnims
                        );
                    }
                }
                $x++;
            }
        }

        foreach ($scrollEvents as $event) {
            $time = $event['time'];
            $fromY = -($event['offset'] * $charHeight);
            $toY = -($event['offset'] + 1) * $charHeight;

            $scrollAnimations .= sprintf(
                '        <animateTransform attributeName="transform" type="translate" from="0 %.2F" to="0 %.2F" begin="loop.begin+%.4fs" dur="0.001s" fill="freeze" />' . "\n",
                $fromY,
                $toY,
                $time
            );
        }

        return [$textElements, $rectElements, $scrollAnimations];
    }

    // Helper function to find a cell with matching style and timing
    private function findCellMatching(array &$lifespans, array $targetCell): ?array
    {
        foreach ($lifespans as $cell) {
            if (isset($cell['startTime']) &&
                $cell['startTime'] === $targetCell['startTime'] &&
                (!isset($cell['endTime']) && !isset($targetCell['endTime']) ||
                 (isset($cell['endTime']) && isset($targetCell['endTime']) && $cell['endTime'] === $targetCell['endTime'])) &&
                $cell['style'] === $targetCell['style']) {
                return $cell;
            }
        }
        return null;
    }

    // Helper function to mark a cell as processed to avoid re-rendering
    private function markCellProcessed(array &$lifespans, array $targetCell): void
    {
        foreach ($lifespans as $key => &$cell) {
            // This condition must be identical to the one in findCellMatching
            if (isset($cell['startTime']) &&
                $cell['startTime'] === $targetCell['startTime'] &&
                (!isset($cell['endTime']) && !isset($targetCell['endTime']) ||
                 (isset($cell['endTime']) && isset($targetCell['endTime']) && $cell['endTime'] === $targetCell['endTime'])) &&
                $cell['style'] === $targetCell['style']) {
                unset($cell['startTime']); // Unsetting start time marks it as processed
                return;
            }
        }
    }

    private function getSvgTemplate(float $width, float $height, string $mainText, string $mainRects, string $mainScroll, string $altText, string $altRects, string $altScroll, string $mainAnims, string $altAnims, string $cursorAnims, float $totalDuration): string
    {
        $fontFamily = $this->config['font_family'];
        $fontSize = $this->config['font_size'];
        $bgColor = $this->config['default_bg'];
        $fgColor = $this->config['default_fg'];
        $cursorWidth = $this->config['font_size'] * 0.6;
        $cursorHeight = $this->config['font_size'] * $this->config['line_height_factor'];
        $loopDuration = $totalDuration + 5; // 5 seconds pause
        $resetScroll = '        <animateTransform attributeName="transform" type="translate" to="0,0" dur="0.001s" begin="loop.begin" fill="freeze" />' . "\n";

        // Build the CSS style block from collected rules
        $cssStyles = '';
        if (!empty($this->cssRules)) {
            $cssStyles .= "    <style>\n";
            $flippedRules = array_flip($this->cssRules);
            ksort($flippedRules); // Sort by class name (c1, c2, etc.)
            foreach ($flippedRules as $className => $rule) {
                $cssStyles .= "      .{$className} { {$rule} }\n";
            }
            $cssStyles .= "    </style>\n";
        }

        return <<<SVG
<svg width="{$width}" height="{$height}" xmlns="http://www.w3.org/2000/svg" font-family='{$fontFamily}' font-size="{$fontSize}">
    <title>Terminal Session Recording</title>
{$cssStyles}
    <rect width="100%" height="100%" fill="{$bgColor}" />
    <g id="master">
        <animate id="loop" attributeName="visibility" from="hidden" to="visible" begin="0;loop.end" dur="{$loopDuration}s" />
        <g id="main-screen" display="inline">
{$mainAnims}
            <g class="terminal-screen" transform="translate(0, 0)" visibility="hidden" text-rendering="geometricPrecision">
                <set attributeName="visibility" to="visible" begin="loop.begin" />
{$resetScroll}{$mainScroll}{$mainRects}{$mainText}
            </g>
        </g>
        <g id="alt-screen" display="none">
{$altAnims}
            <g class="terminal-screen" transform="translate(0, 0)" visibility="hidden" text-rendering="geometricPrecision">
                <set attributeName="visibility" to="visible" begin="loop.begin" />
{$resetScroll}{$altScroll}{$altRects}{$altText}
            </g>
        </g>
        <rect id="cursor" width="{$cursorWidth}" height="{$cursorHeight}" fill="{$fgColor}" opacity="0.7" visibility="visible">
{$cursorAnims}
        </rect>
    </g>
</svg>
SVG;
    }

    private function recordCursorState(): void
    {
        // First, find the most recent coordinates we've logged to see if the
        // cursor has actually moved from its last known position.
        $lastPositionEvent = null;
        foreach (array_reverse($this->cursorEvents) as $event) {
            if (isset($event['x'])) {
                $lastPositionEvent = $event;
                break;
            }
        }

        // If the cursor's current X and Y are the same as the last ones we
        // logged, there's nothing to do.
        if ($lastPositionEvent !== null && $lastPositionEvent['x'] === $this->cursorX && $lastPositionEvent['y'] === $this->cursorY) {
            return;
        }

        $newEvent = ['time' => $this->currentTime, 'x' => $this->cursorX, 'y' => $this->cursorY];

        // Before adding the event, check if the
        // very last event in our log occurred at the exact same time.
        $lastKey = array_key_last($this->cursorEvents);
        if ($lastKey !== null) {
            $lastEvent = $this->cursorEvents[$lastKey];
            // If it was a position event at the same time, replace it.
            if (isset($lastEvent['x']) && $lastEvent['time'] === $this->currentTime) {
                $this->cursorEvents[$lastKey] = $newEvent;
                return;
            }
        }

        // Otherwise, it's a new, distinct movement. Add it to the list.
        $this->cursorEvents[] = $newEvent;
    }

    private function setCursorVisibility(bool $visible): void
    {
        if ($this->cursorVisible !== $visible) {
            $this->cursorVisible = $visible;
            $this->cursorEvents[] = ['time' => $this->currentTime, 'visible' => $this->cursorVisible];
        }
    }

    private function generateCursorAnimations(float $charWidth, float $charHeight): string
    {
        $anims = '';
        foreach ($this->cursorEvents as $event) {
            if (isset($event['visible'])) {
                $to = $event['visible'] ? 'visible' : 'hidden';
                $anims .= sprintf('        <set attributeName="visibility" to="%s" begin="loop.begin+%.4fs" />' . "\n", $to, $event['time']);
            } else {
                $toX = $event['x'] * $charWidth;
                $toY = $event['y'] * $charHeight;
                $anims .= sprintf('        <set attributeName="x" to="%.2F" begin="loop.begin+%.4fs" />' . "\n", $toX, $event['time']);
                $anims .= sprintf('        <set attributeName="y" to="%.2F" begin="loop.begin+%.4fs" />' . "\n", $toY, $event['time']);
            }
        }

        // Reset the cursor to its state at time 0 at the beginning of each loop.
        $initialX = 0.0;
        $initialY = 0.0;
        $initialVisibility = 'visible'; // Default defined on the <rect>

        // Find initial position from the first event that has it
        foreach ($this->cursorEvents as $event) {
            if (isset($event['x'])) {
                $initialX = $event['x'] * $charWidth;
                $initialY = $event['y'] * $charHeight;
                break;
            }
        }
        // Find initial visibility from the first event that has it
        foreach ($this->cursorEvents as $event) {
            if (isset($event['visible'])) {
                $initialVisibility = $event['visible'] ? 'visible' : 'hidden';
                break;
            }
        }

        $anims .= sprintf('        <set attributeName="x" to="%.2F" begin="loop.begin"/>' . "\n", $initialX);
        $anims .= sprintf('        <set attributeName="y" to="%.2F" begin="loop.begin"/>' . "\n", $initialY);
        $anims .= sprintf('        <set attributeName="visibility" to="%s" begin="loop.begin"/>' . "\n", $initialVisibility);

        return $anims;
    }

    private function getClassName(string $rule): string
    {
        if (empty($rule)) {
            return '';
        }
        if (!isset($this->cssRules[$rule])) {
            $this->classCounter++;
            $this->cssRules[$rule] = 'c' . $this->classCounter;
        }
        return $this->cssRules[$rule];
    }
}
